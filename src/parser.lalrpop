use crate::ast::*;

grammar;


pub Comma: &'input str = {
    ","
};

pub Args: Vec<Term> = {
    <var:Var> <c:Comma> <args:Args> => {
        let mut args = args;
        args.push(Term::Var(var));
        args
    },
    <a:Atom> <c:Comma> <args:Args> => {
        let mut args = args;
        args.push(Term::Atom(a));
        args
    },
    <compound:Compound> <c:Comma> <args:Args> => {
        let mut args = args;
        args.push(Term::Compound(compound));
        args
    },
    <v:Var> ")" => {
        let args = vec![Term::Var(v)];
        args
    },
    <a:Atom> ")" => {
        let args = vec![Term::Atom(a)];
        args
    },
    <c:Compound> ")" => {
        let args = vec![Term::Compound(c)];
        args
    }
};

pub Body: Vec<Compound> = {
    <a:Atom> <c:Comma> <body:Body> => {
        let mut body = body;
        body.push(Term::Atom(a).structuralize().unwrap());
        body
    },
    <compound:Compound> <c:Comma> <body:Body> => {
        let mut body = body;
        body.push(Term::Compound(compound).structuralize().unwrap());
        body
    },
    <a:Atom> "." => {
        let body = vec![Term::Atom(a).structuralize().unwrap()];
        body
    },
    <c:Compound> "." => {
        let body = vec![Term::Compound(c).structuralize().unwrap()];
        body
    }
};

pub Atom: Atom = {
    // unquoted atoms
    <r"[a-z]+[A-Za-z_0-9]*"> => Atom(<>.parse().unwrap()),
    // quoted atoms
    <r"'[A-Za-z0-9_]*'"> => Atom(<>.parse().unwrap())
};

pub Var: Var = {
    // leading underscore variables (anonymous)
    <r"_[A-Za-z0-9_]+"> => Var(String::from(<>)),
    // Capital first variables
    <r"[A-Z][A-Za-z0-9_]*"> => Var(String::from(<>))
};

pub FunctorName: String = {
    <name:r"[a-z]+[A-Za-z_0-9]*\("> => {
        let s = &name[..name.len()-1];

        String::from(s)
    }
};

pub Compound: Compound = {
    <name:FunctorName> <args:Args> => {
        let arity = args.len();
        let mut args = args;
        args.reverse();

        assert!(arity > 0);

        Compound { name: name, arity: arity, args: args }
    }
};

pub Expression: Term = {
    <Atom> "." => Term::Atom(<>),
    <Var> "." => Term::Var(<>),
    <Compound> "." => Term::Compound(<>),
    <head:Atom> ":-" <body:Body> => {
        let head = head.structuralize().unwrap();
        let mut body = body;
        body.reverse();
        let rule = Rule { head: head, body: body };
        Term::Rule(rule)
    },
    <head:Compound> ":-" <body:Body> => {
        let mut body = body;
        body.reverse();
        let rule = Rule { head: head, body: body };
        Term::Rule(rule)
    }
}