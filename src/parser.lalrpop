use crate::ast::*;

grammar;

pub Const: Const = {
    <r"[a-z]+[A-Za-z_0-9]*"> => Const(<>.parse().unwrap()),
    <r"'[A-Za-z0-9 _]*'"> => {
        let s: String = <>.parse().unwrap();
        let s = &s[1..s.len()-1];

        Const(String::from(s))
    },
};

pub Var: Var = {
    // leading underscore variables (anonymous)
    <r"_[A-Za-z0-9_]+"> => Var(String::from(<>), 0),
    // Capital first variables
    <r"[A-Z][A-Za-z0-9_]*"> => Var(String::from(<>), 0)
};

pub FunctorName: String = {
    <name:r"[a-z]+[A-Za-z_0-9]*\("> => {
        let s = &name[..name.len()-1];
        String::from(s)
    }
};

pub Args: Vec<Term> = {
    <var:Var> "," <args:Args> => {
        let mut args = args;
        args.push(Term::Var(var));
        args
    },
    <a:Atom> "," <args:Args> => {
        let mut args = args;
        args.push(Term::Atom(a));
        args
    },
    <v:Var> ")" => {
        let args = vec![Term::Var(v)];
        args
    },
    <a:Atom> ")" => {
        let args = vec![Term::Atom(a)];
        args
    },
};

pub Atom: Atom = {
    <Const> => Atom { name: <>, arity: 0, args: vec![] },
    <name:FunctorName> <args:Args> => {
        let arity = args.len();
        let mut args = args;
        args.reverse();

        assert!(arity > 0);
        assert!(arity == args.len());

        Atom { name: Const(name), arity: arity, args: args }
    }
};

pub Clause: Clause = {
    <Atom> "." => vec![<>],
    <a:Atom> "," <c:Clause> => {
        let mut goals = c;
        goals.push(a);
        goals
    }
};

pub Assertion: Assertion = {
    <a:Atom> "." => {
        Assertion { head: a, clause: vec![] }
    },
    <a:Atom> ":-" <clause:Clause> => {
        let mut clause = clause;
        clause.reverse();
        Assertion { head: a, clause: clause }
    },
};

pub Code: Vec<Assertion> = {
    <Assertion> => vec![<>],
    <c:Assertion> <cs:Code> => {
        let mut cs = cs;
        cs.push(c);
        cs
    }
};
